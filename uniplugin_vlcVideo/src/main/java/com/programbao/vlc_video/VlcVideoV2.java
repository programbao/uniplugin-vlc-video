package com.programbao.vlc_video;

// Source code is unavailable, and was generated by the Fernflower decompiler.

import android.animation.ObjectAnimator;
import android.animation.ValueAnimator;
import android.app.Activity;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.hardware.SensorManager;
import android.net.Uri;
import android.os.Handler;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.KeyEvent;
import android.view.OrientationEventListener;
import android.view.SurfaceView;
import android.view.TextureView;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import com.alibaba.fastjson.JSONObject;
import com.taobao.weex.WXSDKInstance;
import com.taobao.weex.annotation.JSMethod;
import com.taobao.weex.bridge.JSCallback;
import com.taobao.weex.ui.action.BasicComponentData;
import com.taobao.weex.ui.component.WXComponent;
import com.taobao.weex.ui.component.WXComponentProp;
import com.taobao.weex.ui.component.WXVContainer;

//import org.videolan.libvlc.IVLCVout;
import org.videolan.libvlc.LibVLC;
import org.videolan.libvlc.Media;
import org.videolan.libvlc.MediaPlayer;
import org.videolan.libvlc.interfaces.IVLCVout;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import io.dcloud.feature.uniapp.annotation.UniJSMethod;

//import javax.naming.Context;

public class VlcVideoV2 extends WXComponent<RelativeLayout> {
    private String TAG = "VlcVideo";
    private LibVLC mLibVLC;
    private MediaPlayer mMediaPlayer;

    private SurfaceView surfaceView;

    private RelativeLayout vlcContainerView;

    RelativeLayout mRootView;


    private LinearLayout mControlTopLayout;
    private RelativeLayout mControlBottomLayout;


    private IVLCVout vlcVout;
    Activity activity; // 在初始化时传入

    private FrameLayout fullscreenContainer; // 用于全屏播放器的容器
    private boolean isFullscreen = false; // 标记是否处于全屏模式

    private OrientationEventListener orientationEventListener;  // 横竖屏变化事件监听

    public VlcVideoV2(WXSDKInstance instance, WXVContainer parent, BasicComponentData basicComponentData) {
        super(instance, parent, basicComponentData);
        activity = (Activity) instance.getContext();
    }

    @Override
    protected RelativeLayout initComponentHostView(Context context) {
        initPlay(context);
        // 添加返回键事件监听器
//        vlcContainerView.setFocusableInTouchMode(true);
//        vlcContainerView.requestFocus();
//        vlcContainerView.setOnKeyListener(this);
        return mRootView;
    }



// 在你的 Activity 或 Fragment 中初始化 OrientationEventListener


    public void initPlay(Context context) {
        Object localObject = new ArrayList();
        ((ArrayList)localObject).add("-vvv");
        ((ArrayList)localObject).add("--no-drop-late-frames");
        ((ArrayList)localObject).add("--no-skip-frames");
        ((ArrayList)localObject).add("--rtsp-tcp");
        ((ArrayList)localObject).add("--avcodec-hw=any");
        ((ArrayList)localObject).add("--live-caching=0");
        mLibVLC = new LibVLC(context, (ArrayList<String>) localObject);
        mMediaPlayer = new MediaPlayer(mLibVLC);
        VlcVideoView vlcVideoView = new VlcVideoView(context);

        /*获取布局元素*/
        surfaceView = vlcVideoView.getVideoView();
        vlcContainerView = vlcVideoView.getVlcContainerView();
        mRootView = vlcVideoView.getmRootView();
        mControlTopLayout = vlcVideoView.getmControlTopLayout();
        mControlBottomLayout = vlcVideoView.getmControlBottomLayout();

        vlcVout = mMediaPlayer.getVLCVout();

        ImageView fullControll = vlcVideoView.getFullControll();
        fullControll.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                System.out.println("点击点击 --" + v.getId());
                if (isFullscreen) {
                    exitFullScreen(null, null);
                } else {
                    enterFullScreen(null, null);
                }
                // 在按钮点击时执行的代码
                // 例如：处理按钮点击事件
            }
        });
        mMediaPlayer.setEventListener(new MediaPlayer.EventListener() {
            @Override
            public void onEvent(MediaPlayer.Event event) {
                // 处理播放事件
                videoPlayerEvent(event);
            }
        });

//        orientationEventListener = new OrientationEventListener(getContext(), SensorManager.SENSOR_DELAY_NORMAL) {
//            @Override
//            public void onOrientationChanged(int orientation) {
//                // 这里会在屏幕方向发生变化时调用
//                // orientation 变量包含了当前的屏幕方向，通常是 0、90、180、270 等值
//                // 在这里可以根据需要执行相关操作
//                System.out.println("横竖屏变化了 ------");
//                if (orientation == 90 || orientation == 270) {
//                    // 手机处于横屏方向，执行你的操作
//                    // 注意：这里的操作可能会在不同方向之间切换多次，你可以加入一些条件来控制只在特定方向执行操作
//                    System.out.println("横竖屏变化了 ------");
//                }
//            }
//        };
//        // 启用方向监听器
//        orientationEventListener.enable();
    }

    @WXComponentProp(name = "play")
    public void play(String path) {
        mMediaPlayer.stop();
        vlcVout.detachViews();
        surfaceView.post(new Runnable() {
            @Override
            public void run() {
                // 在子线程中准备播放
                int width = surfaceView.getWidth();
                int height = surfaceView.getHeight();
                System.out.println("width:" + width + " height:" + height);
                vlcVout.setVideoSurface(surfaceView.getHolder().getSurface(), surfaceView.getHolder());
                vlcVout.setWindowSize(width, height);
                vlcVout.attachViews();
                try {
                    Media media = new Media(mLibVLC, Uri.parse(path));
                    media.setHWDecoderEnabled(true, false);
                    media.addOption(":network-caching=100");
                    media.addOption(":clock-jitter=0");
                    media.addOption(":clock-synchro=0");
                    media.addOption(":fullscreen");
                    mMediaPlayer.setAspectRatio(width + ":" + height);
                    mMediaPlayer.setMedia(media);
                    media.release();
                } catch (Exception var4) {
                    throw new RuntimeException("Invalid asset folder");
                }
//                System.out.println("vlcContainerView.getHeight: " + vlcContainerView.getHeight());
//                // 创建一个定时器,延迟3秒执行
//                new Handler().postDelayed(new Runnable() {
//                    @Override
//                    public void run() {
//                        enterFullScreen();
//                    }
//                }, 3000); // 3秒delay
////
//                new Handler().postDelayed(new Runnable() {
//                    @Override
//                    public void run() {
//                        exitFullScreen();
//                    }
//                }, 10000);
                new Handler().postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        vlcContainerView.postDelayed(mHideControllerRunnable, 3000);
                    }
                }, 3000); // 3秒delay
                mMediaPlayer.play();
            }
        });
    }


    private boolean mControllerShow = true;
    /**
     * 显示控制面板
     */
    private final Runnable mShowControllerRunnable = () -> {
        if (!mControllerShow) {
            showController();
        }
    };

    /**
     * 隐藏控制面板
     */
    private final Runnable mHideControllerRunnable = () -> {
        if (mControllerShow) {
            hideController();
        }
    };
    /**
     * 显示面板
     */
    public void showController() {
        if (mControllerShow) {
            return;
        }
        mControllerShow = true;
        ObjectAnimator.ofFloat(mControlTopLayout, "translationY", -mControlTopLayout.getHeight(), 0).start();
        ObjectAnimator.ofFloat(mControlBottomLayout, "translationY", mControlBottomLayout.getHeight(), 0).start();
//        ObjectAnimator.ofFloat(mControlRightLayout, "translationX", mControlRightLayout.getWidth() + getResources().getDimension(R.dimen.padding_5), 0).start();

        ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f);
        animator.setDuration(200);
        animator.addUpdateListener(animation -> {
            float alpha = (float) animation.getAnimatedValue();
//            mControlLeftLayout.setAlpha(alpha);

            if ((int) alpha != 1) {
                return;
            }
//            if (mControlLeftLayout.getVisibility() == INVISIBLE) {
//                mControlLeftLayout.setVisibility(VISIBLE);
//            }
        });
        animator.start();
    }


    /**
     * 隐藏面板
     */
    public void hideController() {
        if (!mControllerShow) {
            return;
        }
        mControllerShow = false;
        ObjectAnimator.ofFloat(mControlTopLayout, "translationY", 0, -mControlTopLayout.getHeight()).start();
        ObjectAnimator.ofFloat(mControlBottomLayout, "translationY", 0, mControlBottomLayout.getHeight()).start();
//        ObjectAnimator.ofFloat(mControlRightLayout, "translationX", 0, mControlRightLayout.getWidth() + getResources().getDimension(R.dimen.padding_5)).start();
        ValueAnimator animator = ValueAnimator.ofFloat(1f, 0f);
        animator.setDuration(200);
        animator.addUpdateListener(animation -> {
            float alpha = (float) animation.getAnimatedValue();
//            mControlLeftLayout.setAlpha(alpha);
            if (alpha != 0f) {
                return;
            }

//            if (mControlLeftLayout.getVisibility() == VISIBLE) {
//                mControlLeftLayout.setVisibility(INVISIBLE);
//            }
        });
        animator.start();
    }

//    private void toggleFullscreen(boolean fullscreen)
//    {
//        WindowManager.LayoutParams attrs = activity.getWindow().getAttributes();
//        if (fullscreen)
//        {
//            attrs.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN;
//            vlcContainerView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
//                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
//                    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
//                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
//                    | View.SYSTEM_UI_FLAG_FULLSCREEN
//                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
//        }
//        else
//        {
//            attrs.flags &= ~WindowManager.LayoutParams.FLAG_FULLSCREEN;
//        }
//        activity.getWindow().setAttributes(attrs);
//    }

    /*进入全屏*/
    @JSMethod
    public void enterFullScreen(JSONObject options, JSCallback callback) {
        if (isFullscreen) return;
        isFullscreen = true;
        // 横屏
        activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        hideNavigationBar();
        new Handler().postDelayed(new Runnable() {
          @Override
          public void run() {
              /*进入全屏*/
              activity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
              ViewGroup localViewGroup = (ViewGroup) activity.getWindow().getDecorView();
              ((ViewGroup)getParent().getHostView()).removeView(getHostView());
              FrameLayout.LayoutParams localLayoutParams = new FrameLayout.LayoutParams(-1, -1);
              localViewGroup.addView(getHostView(), localLayoutParams);
              adjustSurfaceView();
              if (callback != null) {
                  callback.invoke(isFullscreen);
              }
          }
        }, 300);

    }

    /*退出全屏*/
    @JSMethod
    public void exitFullScreen(JSONObject options, JSCallback callback) {
        if (!isFullscreen) return;
        isFullscreen = false;
        // 竖屏
        activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT);
        showNavigationBar();
        // 退出全屏
        new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
                ((ViewGroup) activity.getWindow().getDecorView()).removeView(getHostView());
                ViewGroup localViewGroup = (ViewGroup)getParent().getHostView();
                View localView = getHostView();
                localViewGroup.addView(localView,  new FrameLayout.LayoutParams(-1, -1));

                adjustSurfaceView();
                activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                if (callback != null) {
                    callback.invoke(isFullscreen);
                }
            }
        }, 300);
    }

    // 隐藏导航栏
    public void hideNavigationBar() {
        View decorView = activity.getWindow().getDecorView();
        int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_FULLSCREEN;
        decorView.setSystemUiVisibility(uiOptions);
    }

    // 显示导航栏
    public void showNavigationBar() {
        View decorView = activity.getWindow().getDecorView();
        int uiOptions = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
        decorView.setSystemUiVisibility(uiOptions);
    }
    //    调整播放器视图
    public void adjustSurfaceView() {
        surfaceView.post(new Runnable() {
            @Override
            public void run() {
                // 在子线程中准备播放
                int width = surfaceView.getWidth();
                int height = surfaceView.getHeight();
                vlcVout.setVideoSurface(surfaceView.getHolder().getSurface(), surfaceView.getHolder());
                vlcVout.setWindowSize(width, height);
                vlcVout.attachViews();
                surfaceView.requestLayout();
                System.out.println("width ----" + width + " height ---" + height);
//                mMediaPlayer.setAspectRatio(width + ":" + height);
            }
        });
    }



//    @JSMethod
//    public void setFullScreen () {
//        // 创建一个新的LayoutParams对象
//        // 获取屏幕宽度和高度
//        DisplayMetrics displayMetrics = getContext().getResources().getDisplayMetrics();
//        int screenWidth = displayMetrics.widthPixels;
//        int screenHeight = displayMetrics.heightPixels;
//        System.out.println("screenWidth:" + screenWidth + " screenHeight:" + screenHeight);
//        // 设置SurfaceView的宽度和高度
////                        surfaceView.getLayoutParams().width = screenWidth;
////                        surfaceView.getLayoutParams().height = screenHeight;
//        vlcVout.setWindowSize(screenWidth, screenHeight);
//        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(screenWidth, screenHeight);
//// 设置vlcContainerView的LayoutParams
//        vlcContainerView.setLayoutParams(layoutParams);
//        vlcContainerView.requestLayout(); // 请求布局更新
////        surfaceView.requestLayout();
////        vlcVout.setAspectRatio(screenWidth + ":" + screenHeight);
//        mMediaPlayer.setAspectRatio(screenWidth + ":" + screenHeight);
//    }
//
//    /* 切换横屏 */
//    @JSMethod(uiThread = true)
//    public void changeToLandscape() {
//        Log.d(TAG, "changeToLandscape");
//        JSONObject result = new JSONObject();
//        if (getInstance().getContext() instanceof Activity) {
//            Activity context = (Activity) getInstance().getContext();
//            PolyvScreenUtils.setLandscape(context);
//            //初始为横屏时，状态栏需要隐藏
//            PolyvScreenUtils.hideStatusBar(context);
//            setFullScreen();
////            result.put("orientation", "portrait");
//        } else {
//            Log.e(TAG, "can not get Activity context");
//            result.put("errMsg", "can not get Activity context");
//        }
////        if (callback != null) {
////            callback.invoke(result);
////        }
//    }
//
//    /* 切换竖屏 */
//    @JSMethod(uiThread = true)
//    public void changeToPortrait(JSONObject options, JSCallback callback) {
//        Log.d(TAG, "changeToPortrait");
//        JSONObject result = new JSONObject();
//        if (getInstance().getContext() instanceof Activity) {
//            Activity context = (Activity) getInstance().getContext();
//            PolyvScreenUtils.setPortrait(context);
//            PolyvScreenUtils.reSetStatusBar(context);
////            result.put("orientation", "portrait");
//        } else {
//            Log.e(TAG, "can not get Activity context");
//            result.put("errMsg", "can not get Activity context");
//        }
//        if (callback != null) {
//            callback.invoke(result);
//        }
//    }


    // 暂停
    @JSMethod
    public void pause(JSONObject options, JSCallback callback) {
        log(mMediaPlayer.toString());
        if (mMediaPlayer != null) {
            mMediaPlayer.pause();
        }
    }
    // 播放
    @UniJSMethod(uiThread=false)
    public void toPlay() {
        MediaPlayer localMediaPlayer = this.mMediaPlayer;
        if (localMediaPlayer != null)
            localMediaPlayer.play();
    }

    // 终止
    @UniJSMethod(uiThread=false)
    public void stop() {
        mMediaPlayer.stop();
    }

    // 设置播放速率
    @JSMethod
    public void setRate(JSONObject paramJSONObject) {
        float rate = paramJSONObject.getFloatValue("rate");
        this.mMediaPlayer.setRate(rate);
    }

    // 生命周期方法
    @Override
    public void onActivityStart() {
        super.onActivityStart();
    }

    // 其他生命周期方法
    @Override
    public void onActivityStop() {
        super.onActivityStop();
        this.mMediaPlayer.stop();
        this.vlcVout.detachViews();
    }

    //    进入应用
    @Override
    public void onActivityResume() {
        super.onActivityResume();
        this.mMediaPlayer.play();
        adjustSurfaceView();
    }

    //    应用在后台
    @Override
    public void onActivityPause() {
        super.onActivityPause();
        this.mMediaPlayer.pause();
        this.vlcVout.detachViews();
    }
    @Override
    public void onActivityDestroy() {
        super.onActivityDestroy();
        mMediaPlayer.release();
        mLibVLC.release();
        // 在销毁时禁用方向监听器
        orientationEventListener.disable();
    }
    void callbackEvent(String paramString, Map paramMap)
    {
        int i = getEvents().size();
        int j = 0;
        int m;
        for (int k = 0; ; k++)
        {
            m = j;
            if (k >= i)
                break;
            if (!((String)getEvents().get(k)).equals(paramString))
                continue;
            m = 1;
            break;
        }
        if (m != 0)
        {
            HashMap localHashMap = new HashMap();
            if (paramMap != null)
                localHashMap.put("detail", paramMap);
            fireEvent(paramString, localHashMap);
        }
    }

    private void log(String paramString)
    {
        Log.e("VlcPlugin", paramString);
    }
    private String getVideoFomatTime(long milliseconds) {
//        long milliseconds = paramEvent.getLengthChanged(); // 这是VLC返回的时长值
        // 将毫秒转换为秒
        long seconds = milliseconds / 1000;

        // 计算小时、分钟和秒
        int hours = (int) (seconds / 3600);
        int minutes = (int) ((seconds % 3600) / 60);
        int remainingSeconds = (int) (seconds % 60);

        // 构建时间字符串
        return String.format("%02d:%02d:%02d", hours, minutes, remainingSeconds);
    }
    public void videoPlayerEvent(MediaPlayer.Event paramEvent) {
        int eventType = paramEvent.type;

        switch (eventType) {
            case 256:
                log("MediaChanged");
                break;
            case 258:
                callbackEvent("onOpening", null);
                break;
            case 262:
                callbackEvent("onPlayStopped", null);
                break;
            case 260:
                callbackEvent("onPlaying", null);
                break;
            case 261:
                callbackEvent("onPlayPaused", null);
                break;
            case 266:
                callbackEvent("onPlayError", null);
                break;
            case 267:
                Map<String, Object> timeChangedMap = new HashMap<>();
                long currentMilliseconds = paramEvent.getTimeChanged(); // 这是VLC返回的时长值

                timeChangedMap.put("time", Long.valueOf(currentMilliseconds));
                timeChangedMap.put("currentTimeFormat", getVideoFomatTime(currentMilliseconds));
                callbackEvent("onTimeChanged", timeChangedMap);
                break;
            case 268:
                Map<String, Object> positionChangedMap = new HashMap<>();
                positionChangedMap.put("position", Float.valueOf(paramEvent.getPositionChanged()));
                callbackEvent("onPositionChange", positionChangedMap);
                break;
            case 269:
                log("SeekableChanged: " + paramEvent.getSeekable());
                break;
            case 270:
                log("PausableChanged: " + paramEvent.getPausable());
                break;
            case 276:
                callbackEvent("ESAdded", null);
                break;
            case 277:
                callbackEvent("ESDeleted", null);
                break;
            case 278:
                callbackEvent("ESSelected", null);
                break;
            case 273:
                Map<String, Object> lengthChangedMap = new HashMap<>();
                long milliseconds = paramEvent.getLengthChanged(); // 这是VLC返回的时长值

                lengthChangedMap.put("time", Long.valueOf(milliseconds));
                lengthChangedMap.put("totalTimeFormat", getVideoFomatTime(milliseconds));
                callbackEvent("onTotalTime", lengthChangedMap);
                break;
            case 286:
                log("RecordChanged: " + paramEvent.getRecordPath());
                break;
            case 274:
                log("Vout: " + paramEvent.getVoutCount());
                break;
            default:
                // Handle other event types or ignore them
                break;
        }
    }


//    @Override
//    public boolean onKey(View view, int keyCode, KeyEvent event) {
//        // 检查是否按下了返回键
//        if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_UP) {
//            // 执行你的返回操作
//            handleBackButtonPress();
//            return true; // 返回 true 表示已处理返回事件
//        }
//        return false; // 返回 false 表示未处理返回事件
//    }
//    private void handleBackButtonPress() {
//        // 处理返回事件的代码
//        // 可以是退出全屏、停止播放等操作
//        if (isFullscreen) {
//            exitFullScreen(null, null);
//        } else {
//            // 处理非全屏状态下的返回操作
//            // 可能是停止播放、关闭播放器等操作
////            stopPlayback();
//        }
//    }

}